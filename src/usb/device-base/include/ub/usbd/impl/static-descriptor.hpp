#ifndef UB_USB_DEVICE_BASE_USBD_IMPL_STATIC_DESCRIPTOR_H
#define UB_USB_DEVICE_BASE_USBD_IMPL_STATIC_DESCRIPTOR_H

#include <cstddef>
#include <cstdint>

#include <ub/usbd/serial-config.hpp>
#include <ub/usbd/pcd-interface.hpp>

/** This version is included in generated descriptor code to enforce re-generation on library updates */
#define UB_USBD_STATIC_DESCRIPTOR_VERSION                       2023110201

namespace ub::usbd::descriptor {
    /** Physical (present on the wire) to logical (function number & function endpoints) value mapping */
    struct EndpointMapping {
        /** Special value to use when value is not mapped */
        constexpr static uint8_t NOT_MAPPED    = 0;

        // Data is encoded as ((func + 1) << 4) | value
        // unmapped value is encoded as 0x00 to allow arrays to be bigger than generated data

        uint8_t     in  [UB_USBD_MAX_IN_ENDPOINTS];     //! IN to logical endpoint mapping
        uint8_t     out [UB_USBD_MAX_OUT_ENDPOINTS];    //! OUT to logical endpoint mapping
        uint8_t     intf[UB_USBD_MAX_INTERFACES];       //! Interface to logical mapping

        /** @return Function index encoded in the mapping data */
        static inline uint8_t functionIdx(uint8_t mapped) { return (uint8_t) (mapped >> 4) - 1; }

        /** @return Mapped value or interface index encoded in mapping data */
        static inline uint8_t mappedIdx(uint8_t mapped) { return (uint8_t) (mapped & 0x0F); }
    };

    /** String descriptor definition */
    struct StringDescriptor {
        uint8_t         index;          //! Index of string descriptor
        const uint8_t   *ptr;           //! Descriptor data (length encoded in the first byte)
    };

    /** Static function metadata */
    struct StaticFunction {
        /** Function type code to ensure that runtime registered functions match statically configured ones */
        uint32_t            functionType;

        /** Function-specific additional data pointer, {@code nullptr} when not used */
        const void          *functionData;

#if UB_USBD_HAVE_DATA_ENDPOINTS
        /** Logical-to-physical endpoint mapping. Stored in inverted form to allow 0x00 to be invalid value */
        uint8_t             endpoints[UB_USBD_MAX_FUNC_ENDPOINTS];
#endif

        /** Number of first interface allocated to the function */
        uint8_t             interfaceBase;
    };

    /** Static descriptor structure, generated by Python helper script and stored in device flash */
    struct StaticDescriptor {
        /** Pre-computed device descriptor data. Length encoded in first byte */
        const uint8_t       *deviceDescriptor;

        /** Pre-computed configuration descriptor data. Length encoded in wTotalLength field. */
        const uint8_t       *configDescriptor;

        /** Number of functions in descriptor */
        uint8_t             functionCount;

        /** Total number of string descriptors */
        uint8_t             stringDescriptorCount;

        /** Index of serial number string descriptor */
        uint8_t             serialNumberString;

#if UB_USBD_HAVE_DATA_ENDPOINTS
        /** Number of entries in the `endpoints` array. */
        uint8_t             endpointCount;
#endif

        /** String descriptor data */
        const StringDescriptor *strings;

#if UB_USBD_HAVE_DATA_ENDPOINTS
        /** Endpoint mapping data */
        EndpointMapping     endpointMapping;

        /** Endpoint configuration data */
        const EndpointConfig *endpoints;
#endif

        /** Array with function definitions */
        const StaticFunction *functions;
    };
}

namespace ub::usbd {
    using StaticDescriptor = ub::usbd::descriptor::StaticDescriptor;
}

#endif // UB_USB_DEVICE_BASE_USBD_IMPL_STATIC_DESCRIPTOR_H
