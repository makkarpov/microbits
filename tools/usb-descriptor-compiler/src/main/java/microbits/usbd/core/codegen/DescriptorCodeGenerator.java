package microbits.usbd.core.codegen;

import microbits.usbd.api.codegen.TargetCodeGenerator;
import microbits.usbd.api.codegen.TargetConfigurationData;
import microbits.usbd.api.descriptor.Descriptor;
import microbits.usbd.api.endpoint.EndpointAllocation;
import microbits.usbd.api.plugin.FunctionInstance;
import microbits.usbd.api.target.LinkSpeed;
import microbits.usbd.core.DescriptorCompiler;
import microbits.usbd.core.descriptor.DescriptorContext;
import microbits.usbd.core.descriptor.DescriptorSerializer;
import microbits.usbd.core.descriptor.IndexedStringDescriptor;
import microbits.usbd.core.descriptor.SerializedDescriptor;
import microbits.usbd.core.state.DescriptorState;
import microbits.usbd.core.state.FunctionState;
import microbits.usbd.core.state.InterfaceMapping;
import microbits.usbd.core.util.PrinterUtils;
import microbits.usbd.core.util.Utils;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToIntFunction;

public class DescriptorCodeGenerator {
    public static final int LIBRARY_VERSION = 202311110;

    private final DescriptorCompiler compiler;
    private final CodePrintStream output;

    private ConfigChecksGenerator checksGenerator;
    private TargetCodeGenerator targetGenerator;
    private boolean targetConfigPresent;

    private Set<Integer> functionConfigs;
    private List<LinkSpeed> speeds;

    private int stringDescriptorCount;

    public DescriptorCodeGenerator(DescriptorCompiler compiler, CodePrintStream output) {
        this.compiler = compiler;
        this.output = output;
    }

    private void setupCodeGeneration() {
        for (FunctionState st: compiler.functions()) {
            st.codeGenerator = st.impl.codeGenerator();
        }

        Supplier<TargetCodeGenerator> targetGenFn = compiler.target().codeGenerator;
        targetGenerator = targetGenFn != null ? targetGenFn.get() : new GenericTargetGenerator();

        checksGenerator = new ConfigChecksGenerator(compiler, targetGenerator);
        speeds = compiler.descriptors().keySet().stream()
                .sorted(Comparator.naturalOrder())
                .toList();
    }

    private void appendHeader(StringBuilder sb, String x) {
        sb.append("** ").append(x).append(" ");
        sb.append("*".repeat(CodePrintStream.MAX_WIDTH - 4 - x.length()));
        sb.append("\n\n");
    }

    private void generateHeaderComment() {
        StringBuilder sb = new StringBuilder();

        sb.append("\nThis file is auto-generated by the USB descriptor compiler tool. Do not edit.\n\n");

        sb.append("Generated at:  ");
        sb.append(DateTimeFormatter.RFC_1123_DATE_TIME.format(ZonedDateTime.now()));
        sb.append("\n");

        sb.append("Target device: ").append(compiler.target().name).append("\n");
        sb.append("Link speed:    ").append(compiler.speed().name()).append("\n");

        sb.append("\n");

        appendHeader(sb, "Suggested configuration values:");
        checksGenerator.writeSuggestedValues(sb);
        sb.append("\n");

        output.printComment(sb.toString(), true);
        output.printEmptyLine();
    }

    private void generateIncludes() {
        output.printInclude("ub/usbd/static-config.hpp");
        output.markAsIncluded("ub/usbd/config.hpp");

        for (FunctionState st: compiler.functions()) {
            if (st.codeGenerator == null) {
                continue;
            }

            for (String file: st.codeGenerator.includeFiles()) {
                output.printInclude(file);
            }
        }

        for (String inc: targetGenerator.includeFiles()) {
            output.printInclude(inc);
        }

        for (String inc: compiler.spec.includes) {
            output.printInclude(inc);
        }

        output.printEmptyLine();
    }

    private void printDeviceDescriptor() {
        DescriptorContext context = new DescriptorContext(compiler.strings(), compiler.speed());
        SerializedDescriptor device = DescriptorSerializer.serialize(context, compiler.deviceDescriptor());

        output.println(String.format("static const uint8_t %s[] = {", DEVICE_DESCRIPTOR_SYMBOL));
        output.writeDescriptorData(device, "  ", true);
        output.println("};");

        output.printEmptyLine();
        output.printEmptyLine();
    }

    private void printStringDescriptors() {
        DescriptorContext context = new DescriptorContext(compiler.strings(), compiler.speed());
        List<IndexedStringDescriptor> descriptors = compiler.strings().descriptors();

        for (IndexedStringDescriptor d: descriptors) {
            output.println(String.format("static const uint8_t %s%d[] = {", STRING_DESCRIPTOR_DATA_SYMBOL, d.index()));

            SerializedDescriptor ser = DescriptorSerializer.serialize(context, d.data());
            output.writeDescriptorData(ser, "  ", true);
            output.println("};");
            output.printEmptyLine();
        }

        output.println(String.format("static const %s %s[] {", STRING_DESCRIPTOR_TYPE, STRING_DESCRIPTORS_SYMBOL));

        for (int i = 0; i < descriptors.size(); i++) {
            IndexedStringDescriptor d = descriptors.get(i);
            StringBuilder line = new StringBuilder();

            line.append("  { ").append(d.index());
            line.append(", ").append(STRING_DESCRIPTOR_DATA_SYMBOL);
            line.append(d.index()).append(" }");

            if (i != descriptors.size() - 1) {
                line.append(",");
            }

            output.println(line);
        }

        output.println("};");

        output.printEmptyLine();
        output.printEmptyLine();

        stringDescriptorCount = descriptors.size();
    }

    private void printConfigDescriptor(LinkSpeed speed) {
        DescriptorContext context = new DescriptorContext(compiler.strings(), speed);

        output.println(String.format("static const uint8_t %s[] = {", configDescriptorSymbol(speed)));

        List<Descriptor> descriptors = compiler.descriptors().get(speed).configDescriptor;
        for (int i = 0; i < descriptors.size(); i++) {
            SerializedDescriptor ser = DescriptorSerializer.serialize(context, descriptors.get(i));
            boolean last = i == descriptors.size() - 1;

            output.writeDescriptorData(ser, "  ", last);
        }

        output.println("};");
        output.printEmptyLine();
    }

    private void printDescriptorData(String prefix) {
        int serialNumberIdx = compiler.spec.device.runtimeSerial
                ? compiler.strings().getIndex(compiler.deviceDescriptor().iSerialNumber)
                : 0;

        output.println(prefix + DEVICE_DESCRIPTOR_SYMBOL + ",");

        StringBuilder line = new StringBuilder();

        line.append(prefix).append("{ ");
        for (int i = 0; i < speeds.size(); i++) {
            if (i != 0) line.append(", ");
            line.append(configDescriptorSymbol(speeds.get(i)));
        }
        line.append(" },");
        output.println(line);

        output.println(prefix + STRING_DESCRIPTORS_SYMBOL + ",");
        output.println(prefix + "/* string count: */ " + stringDescriptorCount + ",");
        output.println("#if UB_USBD_RUNTIME_SERIAL_NUMBER");
        output.println(prefix + "/* serial number index: */ " + serialNumberIdx);
        output.println("#endif");
    }

    private <T> void printFunctionMapping(String prefix, List<T> data, int count, Predicate<T> active,
                                          Function<T, FunctionInstance> fn, ToIntFunction<T> mapped) {
        StringBuilder line = new StringBuilder();
        line.append(prefix).append("{ ");

        for (int i = 0; i < count; i++) {
            if (i != 0) line.append(", ");

            T item = data.get(i);
            int value = 0;

            if (active.test(item)) {
                value = ((fn.apply(item).identifier() + 1) << 4) | mapped.applyAsInt(item);
            }

            PrinterUtils.appendHexByte(line, value);
        }

        line.append(" },");
        output.println(line);
    }

    private void printEndpointMapping(String prefix, List<EndpointAllocation.PhysicalEndpoint> epList, int count) {
        printFunctionMapping(prefix, epList, count, e -> e.active && e.func != null, e -> e.func,
                e -> Objects.requireNonNull(e.defn).logicalAddress);
    }

    private void printFuncEndpoints(String prefix, List<EndpointAllocation.Function> funcs) {
        StringBuilder line = new StringBuilder();
        line.append(prefix).append("{");

        for (int i = 0; i < funcs.size(); i++) {
            if (i != 0) line.append(", ");
            line.append("{ ");

            List<EndpointAllocation.FunctionEp> eps = funcs.get(i).endpoints;
            for (int j = 0; j < eps.size(); j++) {
                if (j != 0) line.append(", ");
                EndpointAllocation.FunctionEp ep = eps.get(j);
                PrinterUtils.appendHexByte(line, ep.number | ep.direction.directionBit);
            }

            line.append(" }");
        }

        line.append("},");
        output.println(line);
    }

    private void printInterfaceBases(String prefix, List<InterfaceMapping.FnData> functions) {
        StringBuilder line = new StringBuilder();
        line.append(prefix).append("{ ");

        for (int i = 0; i < functions.size(); i++) {
            if (i != 0) line.append(", ");
            PrinterUtils.appendHexByte(line, functions.get(i).interfaceBase());
        }

        line.append(" }");
        output.println(line);
    }

    private void printResourceMapping(String prefix, DescriptorState st) {
        output.println("#if UB_USBD_HAVE_DATA_ENDPOINTS");
        printEndpointMapping(prefix, st.endpointAllocation.inEndpoints, st.endpointAllocation.numInEndpoints());
        printEndpointMapping(prefix, st.endpointAllocation.outEndpoints, st.endpointAllocation.numOutEndpoints());
        printFuncEndpoints(prefix, st.endpointAllocation.functions);
        output.println("#endif");

        output.println("#if UB_USBD_MAX_FUNCTIONS");

        printFunctionMapping(prefix, st.interfaces.physical, st.interfaces.numInterfaces(), i -> true,
                InterfaceMapping.FnIntf::st, i -> i.defn().logicalNumber);

        printInterfaceBases(prefix, st.interfaces.functions);

        output.println("#endif");
    }

    private void generateFuncImplConfigs() {
        functionConfigs = new HashSet<>();

        for (FunctionState st: compiler.functions()) {
            if (st.codeGenerator == null) {
                continue;
            }

            String config = st.codeGenerator.generateConfiguration(String.format(FUNC_CONFIG_SYMBOL, st.id));
            if (config == null) {
                continue;
            }

            output.println(config.trim());
            output.printEmptyLine();
            output.printEmptyLine();

            functionConfigs.add(st.id);
        }
    }

    private void generateFuncConfig(String prefix, FunctionState st) {
        output.println("#if UB_USBD_ENABLE_TYPE_IDENTIFIERS");
        output.println(prefix + Utils.formatImplementationId(st.impl.implementationId()) + ",");
        output.println("#endif");

        if (functionConfigs.contains(st.id)) {
            output.println(prefix + "&" + String.format(FUNC_CONFIG_SYMBOL, st.id));
        } else {
            output.println(prefix + "nullptr");
        }
    }

    private void generateTargetConfig() {
        TargetConfigurationData dataImpl = new TargetConfigurationData() {
            @Override
            public List<LinkSpeed> speeds() {
                return DescriptorCodeGenerator.this.speeds;
            }

            @Override
            public EndpointAllocation endpoints(LinkSpeed speed) {
                return compiler.descriptors().get(speed).endpointAllocation;
            }
        };

        String targetCfg = targetGenerator.generateConfiguration(TARGET_CONFIG_SYMBOL, dataImpl);
        if (targetCfg == null) {
            return;
        }

        output.println(targetCfg.trim());
        output.printEmptyLine();
        output.printEmptyLine();

        targetConfigPresent = true;
    }

    private void generateMainConfig(String prefix) {
        output.println("#if UB_USBD_ENABLE_TYPE_IDENTIFIERS");
        output.println(prefix + Utils.formatImplementationId(targetGenerator.targetIdentifier()) + ",");
        output.println("#endif");

        output.println(prefix + (targetConfigPresent ? "&" + TARGET_CONFIG_SYMBOL : "nullptr") + ",");

        output.println(prefix + "/* DescriptorData */ {");
        printDescriptorData(prefix + INDENT_SINGLE);
        output.println(prefix + "}, /* end of DescriptorData */");

        output.println("#if UB_USBD_HAVE_RESOURCE_MAPPING");
        output.println(prefix + "/* ResourceMapping[] */ {");

        for (int i = 0; i < speeds.size(); i++) {
            String nprefix = prefix + INDENT_SINGLE;

            output.println(nprefix + "{");
            printResourceMapping(nprefix + INDENT_SINGLE, compiler.descriptors().get(speeds.get(i)));
            output.println(nprefix + "}" + (i != speeds.size() - 1 ? "," : ""));
        }

        output.println(prefix + "}, /* end of ResourceMapping[] */");
        output.println("#endif");

        output.println(prefix + "/* function count: */ " + compiler.functions().size() + ",");

        output.println(prefix + "/* FunctionConfig[] */ {");

        List<FunctionState> functions = compiler.functions();
        for (int i = 0; i < functions.size(); i++) {
            FunctionState st = functions.get(i);
            String nprefix = prefix + INDENT_SINGLE;

            output.println(nprefix + "{ /* #" + st.id + ": " + st.name + " */");
            generateFuncConfig(nprefix + INDENT_SINGLE, st);
            output.println(nprefix + "}" + (i != functions.size() - 1 ? "," : ""));
        }

        output.println(prefix + "} /* end of FunctionConfig[] */");
    }

    public void run() {
        setupCodeGeneration();

        generateHeaderComment();
        generateIncludes();

        output.println("#if UB_USBD_STATIC_CONFIG_VERSION != " + LIBRARY_VERSION);
        output.println("#error \"Generated descriptor code does not match current library version. Please re-generate.\"");
        output.println("#endif // UB_USBD_STATIC_CONFIG_VERSION");
        output.printEmptyLine();

        checksGenerator.writeChecks(output);
        output.printEmptyLine();

        printDeviceDescriptor();
        printStringDescriptors();

        for (LinkSpeed speed: speeds) {
            printConfigDescriptor(speed);
        }

        generateTargetConfig();
        generateFuncImplConfigs();

        String[] nsParts = compiler.spec.name.split("::");
        for (int i = 0; i < nsParts.length; i++) {
            String prefix = INDENT_SINGLE.repeat(i);

            if (i == nsParts.length - 1) {
                output.println(prefix + "const ::ub::usbd::config::StaticConfiguration " + nsParts[i] + " {");
            } else {
                output.println(prefix + "namespace " + nsParts[i] + " {");
            }
        }

        generateMainConfig(INDENT_SINGLE.repeat(nsParts.length));

        for (int i = nsParts.length - 1; i >= 0; i--) {
            String prefix = INDENT_SINGLE.repeat(i);

            if (i == nsParts.length - 1) {
                output.println(prefix + "};");
            } else {
                output.println(prefix + "} // namespace " + nsParts[i]);
            }
        }
    }

    private static String configDescriptorSymbol(LinkSpeed speed) {
        return CONFIG_DESCRIPTOR_SYMBOL + PrinterUtils.capitalize(speed.name());
    }

    private static final String INDENT_SINGLE                   = "  ";

    private static final String DEVICE_DESCRIPTOR_SYMBOL        = "ub_deviceDescriptor";
    private static final String STRING_DESCRIPTOR_DATA_SYMBOL   = "ub_stringDescriptor";
    private static final String STRING_DESCRIPTORS_SYMBOL       = "ub_stringDescriptors";
    private static final String CONFIG_DESCRIPTOR_SYMBOL        = "ub_configDescriptor";

    private static final String TARGET_CONFIG_SYMBOL            = "ub_targetConfig";
    private static final String FUNC_CONFIG_SYMBOL              = "ub_funcConfig%d";

    private static final String STRING_DESCRIPTOR_TYPE          = "::ub::usbd::config::StringDescriptor";
}
